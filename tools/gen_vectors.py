types = ['byte', 'value']

h = open("vectors.h", "w")
c = open("vectors.c", "w")
h.write("// generated by gen_vectors.py\n")
h.write('#pragma once\n#include "value.h"\n')

c.write("// generated by gen_vectors.py\n")
c.write('#include "vectors.h"\n')

for ty in types:
  h.write("""
typedef struct {
%(ty)s* data;
i32 count, cap;
} %(ty)s_vector;
void %(ty)s_vector_allocate(%(ty)s_vector* vec);
void %(ty)s_vector_pushback(%(ty)s_vector* vec, %(ty)s val);
void %(ty)s_vector_deallocate(%(ty)s_vector* vec);
%(ty)s %(ty)s_vector_pop(%(ty)s_vector* vec);
void %(ty)s_reset(%(ty)s_vector* vec);
"""%{"ty": ty}) 

  c.write(r"""
void %(ty)s_vector_allocate(%(ty)s_vector* vec) {
  vec->data = ALLOCATE(%(ty)s, 8);
  vec->count = 0;
  vec->cap = 8;
}
void %(ty)s_vector_deallocate(%(ty)s_vector* vec) {
  FREE(vec->data);
  vec->count = 0;
  vec->cap = 0;
}
void %(ty)s_reset(%(ty)s_vector* vec) {
  vec->count = 0;
}
void %(ty)s_vector_pushback(%(ty)s_vector* vec, %(ty)s val) {
  if(vec->cap < vec->count +1) {
    vec->cap *= 2;
    vec->data = REALLOCATE(%(ty)s, vec->data, vec->cap);
  }
  vec->data[vec->count] = val;
  vec->count += 1;
}
%(ty)s %(ty)s_vector_pop(%(ty)s_vector* vec) {
  if(vec->count == 0) {
    fprintf(stderr, "Pop on an empty vector(%(ty)s). Aborting\n");
    exit(1);
  }
  vec->count -= 1;
  return vec->data[vec->count];
}
"""%{"ty": ty}) 
